# Rust å­¸ç¿’ç­†è¨˜èˆ‡è¤‡ç¿’æ‰‹å†Š (Rustlings æ”»ç•¥)

é€™ä»½æ–‡ä»¶æ•´ç†äº†åœ¨å®Œæˆ Rustlings ç·´ç¿’éç¨‹ä¸­é‡åˆ°çš„æ ¸å¿ƒå•é¡Œèˆ‡è©³ç´°è§€å¿µè§£æï¼Œä¸¦é™„ä¸Šå¯¦æˆ°ç¯„ä¾‹ã€‚

## 1. è®Šæ•¸èˆ‡åŸºæœ¬å‹åˆ¥ (Variables & Types)
- **mut èˆ‡ä¸å¯è®Šæ€§**ï¼šRust è®Šæ•¸é è¨­ä¸å¯è®Šã€‚
  ```rust
  let mut x = 5;
  x = 6; // OK
  ```
- **Shadowing (é®è”½)**ï¼š
  ```rust
  let x = "5"; 
  let x = x.parse::<i32>().unwrap(); // è®Šæ›´å‹åˆ¥è€Œä¸éœ€æ›å
  ```

## 2. æ‰€æœ‰æ¬Šèˆ‡å€Ÿç”¨ (Ownership & Borrowing)
- **å€Ÿç”¨è¦å‰‡**ï¼š
  - åŒä¸€æ™‚é–“å¯æœ‰ç„¡é™å€‹ä¸å¯è®Šå€Ÿç”¨ `&T`ã€‚
  - åŒä¸€æ™‚é–“åªèƒ½æœ‰ä¸€å€‹å¯è®Šå€Ÿç”¨ `&mut T`ã€‚
  - **Auto-deref**ï¼šå­˜å–æ¬„ä½æ™‚ `p.x` æœƒè‡ªå‹•è™•ç† `(*p).x`ã€‚

## 3. å­—ä¸²è™•ç† (Strings)
- **String vs &str**ï¼š
  ```rust
  let s = "hello".to_string(); // Owned
  let slice = &s[..];         // Borrowed slice
  ```
- **UTF-8 é•·åº¦**ï¼š
  - `.len()`ï¼šä½å…ƒçµ„é•·åº¦ (Bytes)ã€‚
  - `.chars().count()`ï¼šå­—å…ƒé•·åº¦ (Characters)ã€‚

## 4. é›†åˆèˆ‡ HashMaps
- **Entry API**ï¼šæœ€å„ªé›…çš„æ›´æ–°æ–¹å¼ã€‚
  ```rust
  let mut map = HashMap::new();
  *map.entry("key").or_insert(0) += 1;
  ```

## 5. éŒ¯èª¤è™•ç† (Error Handling)
- **`?` é‹ç®—å­**ï¼šæˆåŠŸå‰‡è§£é–‹å€¼ï¼Œå¤±æ•—å‰‡ææ—©å›å‚³ã€‚
- **map_err**ï¼šç¿»è­¯éŒ¯èª¤å‹åˆ¥ã€‚
  ```rust
  s.parse::<i32>().map_err(|e| MyError::InvalidFormat)?
  ```
- **å–å‡º Error**ï¼šä½¿ç”¨ `match` æˆ– `if let Err(e) = res`ã€‚

## 6. æ³›å‹èˆ‡ Trait (Generics & Traits)
- **impl Trait vs <T>**ï¼š
  - `impl Trait`ï¼šç”¨æ–¼å‡½å¼åƒæ•¸/å›å‚³å€¼çš„ç°¡å¯«ã€‚
  - `<T: Trait>`ï¼šç”¨æ–¼çµæ§‹é«”å®šç¾©æˆ–è¤‡é›œé™åˆ¶ã€‚
- **derive**ï¼šè‡ªå‹•å¯¦ä½œå¸¸ç”¨è¡Œç‚ºï¼ˆDebug, Clone, Defaultï¼‰ã€‚

## 7. è¿­ä»£å™¨ (Iterators)
- **ä¸‰å¤§æ‘ºç–Š**ï¼š
  - `map`ï¼š1 å° 1 è½‰æ›ã€‚
  - `flat_map`ï¼š1 å°å¤šä¸¦æ”¤å¹³ï¼ˆè™•ç†åµŒå¥—çµæ§‹å¿…å‚™ï¼‰ã€‚
  - `fold`ï¼šå¤šå° 1 æ­¸ç´ã€‚
- **collect**ï¼šå°‡è¿­ä»£å™¨è½‰å›é›†åˆï¼Œæ”¯æ´ `Result<Vec<T>, E>`ï¼ˆä¸€éŒ¯å…¨éŒ¯ï¼‰ã€‚

## 8. å¤šåŸ·è¡Œç·’èˆ‡é€šè¨Š (Concurrency)
- **Arc<Mutex<T>>**ï¼šå…±äº«ä¸”å¯è®Šè³‡æ–™çš„å…¬å¼ã€‚
- **mpsc (Channel)**ï¼šå¤šç«¯ç”Ÿç”¢è€…ï¼Œå–®ç«¯æ¶ˆè²»è€…ã€‚
  ```rust
  let (tx, rx) = mpsc::channel();
  let tx1 = tx.clone(); // è¤‡è£½ç™¼é€ç«¯
  thread::spawn(move || tx1.send(10));
  for val in rx { println!("{val}"); }
  ```

## 9. æ™ºæ…§æŒ‡æ¨™ (Smart Pointers)
- **Box**ï¼šæ”¾åœ¨ Heapï¼Œè§£æ±ºéè¿´å‹åˆ¥å¤§å°å•é¡Œã€‚
- **Rc / Arc**ï¼šå¼•ç”¨è¨ˆæ•¸ï¼Œæ”¯æ´ã€Œå¤šäººå…±åŒæ“æœ‰ã€ã€‚
- **Cow**ï¼šå¯«å…¥æ™‚å…‹éš†ï¼Œè¿½æ±‚æ•ˆèƒ½å„ªåŒ–ï¼ˆèƒ½å€Ÿå°±ä¸è²·ï¼‰ã€‚

## 10. å‹åˆ¥è½‰æ› (Conversions)
- **as é‹ç®—å­**ï¼šé¡¯æ€§å¼·åˆ¶è½‰æ›ã€‚`let x = 10 as f64;`ã€‚
- **From / Into**ï¼šä¿è­‰æˆåŠŸçš„è½‰æ›ã€‚
- **TryFrom / TryInto**ï¼šå¯èƒ½å¤±æ•—çš„è½‰æ›ï¼Œå›å‚³ `Result`ã€‚
  ```rust
  let r: u8 = u8::try_from(256i16).unwrap_err(); // è¶…å‡ºç¯„åœ
  ```
- **AsRef / AsMut**ï¼šå»‰åƒ¹çš„å¼•ç”¨è½‰å¼•ç”¨ã€‚è®“å‡½å¼èƒ½æ¥æ”¶ä»»ä½•ã€Œå¯ä»¥çœ‹ä½œæ˜¯æŸç¨®å¼•ç”¨ã€çš„å‹åˆ¥ã€‚
  ```rust
  // AsRef: è®“å‡½å¼åŒæ™‚æ”¯æ´ String, &str æˆ– Path
  fn open_file<P: AsRef<Path>>(path: P) {
      let path = path.as_ref();
      // ...
  }

  // AsMut: å¸¸ç”¨æ–¼ä¿®æ”¹ Box æˆ–å…§å®¹ç‰©
  fn num_sq<T: AsMut<u32>>(arg: &mut T) {
      let val = arg.as_mut();
      *val *= *val;
  }
  ```

## 11. Clippy æœ€ä½³å¯¦è¸ ğŸ“
- **é¿å… check-then-unwrap**ï¼šç›´æ¥ç”¨ `if let Some(x) = opt`ã€‚
- **è®Šæ•¸äº¤æ›**ï¼šä½¿ç”¨ `std::mem::swap(&mut a, &mut b)`ã€‚
- **æœ‰æ•ˆæ¸…ç©º**ï¼šä½¿ç”¨ `vec.clear()` è€Œä¸æ˜¯é‡æ–°è³¦å€¼ã€‚

---
*Generated by Gemini CLI - 2026-02-23*
